Total: 8.50s
ROUTINE ======================== github.com/shaia/go-simd-bloomfilter.(*CacheOptimizedBloomFilter).getHashPositionsOptimized in c:\Users\shaia\development\BloomFilter\bloomfilter.go
     3.32s      4.35s (flat, cum) 51.18% of Total
      50ms       50ms    438:func (bf *CacheOptimizedBloomFilter) getHashPositionsOptimized(data []byte) {
      10ms      100ms    439:	h1 := hashOptimized1(data)
      20ms      150ms    440:	h2 := hashOptimized2(data)
         .          .    441:
      90ms       90ms    442:	if bf.useArrayMode {
         .          .    443:		// Array mode: zero-overhead direct indexing
         .          .    444:		// Clear only used indices - O(used) instead of O(capacity)
      50ms       50ms    445:		for _, idx := range bf.usedIndicesHash {
     150ms      150ms    446:			bf.arrayMap[idx] = bf.arrayMap[idx][:0]
         .          .    447:		}
         .          .    448:		bf.usedIndicesHash = bf.usedIndicesHash[:0]
         .          .    449:
         .          .    450:		// Generate positions and group by cache line to improve locality
     380ms      380ms    451:		for i := uint32(0); i < bf.hashCount; i++ {
     110ms      110ms    452:			hash := h1 + uint64(i)*h2
      60ms       60ms    453:			bitPos := hash % bf.bitCount
      40ms       40ms    454:			cacheLineIdx := bitPos / BitsPerCacheLine
         .          .    455:
     410ms      410ms    456:			bf.positions[i] = bitPos
         .          .    457:
         .          .    458:			// Track first use of this cache line index
     530ms      530ms    459:			if len(bf.arrayMap[cacheLineIdx]) == 0 {
     110ms      110ms    460:				bf.usedIndicesHash = append(bf.usedIndicesHash, cacheLineIdx)
         .          .    461:			}
     520ms      520ms    462:			bf.arrayMap[cacheLineIdx] = append(bf.arrayMap[cacheLineIdx], bitPos)
         .          .    463:		}
         .          .    464:	} else {
         .          .    465:		// Map mode: dynamic scaling for large filters
         .          .    466:		// Clear the map efficiently with Go 1.21+ built-in
         .      130ms    467:		clear(bf.mapMap)
         .          .    468:		bf.usedIndicesHash = bf.usedIndicesHash[:0]
         .          .    469:
         .          .    470:		// Generate positions and group by cache line
      10ms       10ms    471:		for i := uint32(0); i < bf.hashCount; i++ {
      30ms       30ms    472:			hash := h1 + uint64(i)*h2
      10ms       10ms    473:			bitPos := hash % bf.bitCount
      10ms       10ms    474:			cacheLineIdx := bitPos / BitsPerCacheLine
         .          .    475:
     140ms      140ms    476:			bf.positions[i] = bitPos
         .          .    477:
         .          .    478:			// Track first use of this cache line index
      10ms      120ms    479:			if _, exists := bf.mapMap[cacheLineIdx]; !exists {
      10ms       10ms    480:				bf.usedIndicesHash = append(bf.usedIndicesHash, cacheLineIdx)
         .          .    481:			}
      40ms      610ms    482:			bf.mapMap[cacheLineIdx] = append(bf.mapMap[cacheLineIdx], bitPos)
         .          .    483:		}
         .          .    484:	}
